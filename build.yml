default: "help"
expose:
  [
    "help",
    "info",
    "promote",
    "docker",
    "refresh",
    "compile",
    "lint",
    "test",
    "release",
    "publish",
  ]
configuration: ~/.dockerhub.yml
# ~/.dockerhub.yml should contains:
# DOCKERHUB_USER: <your dockerhub user>
# DOCKERHUB_PASS: <your dockerhub password or a dockerhub token>

properties:
  # Build Configuration (edit this section to override default values)
  MODULE: "" # leave empty to default to the git remote url (e.g. "github.com/<usename>/<reponame>")
  PROJECT: "" # leave empty to default to the git repository name (e.g. "<reponame>")
  LDFLAGS: "" # add custom standard ldflags, will be applied everywhere everytime
  BUILD_DIR: "bin" # subfolder where the build will output
  # Build parameters (use the -props flag to change these default values)
  latest: false # Do not tag the Docker image with latest, specify othewise with `-props "{latest: true}"`
  ldflags: "" # Specify a additional ldflags with `-props "{ldflags: '<flags>'}"`
  buildpaths: [] # By default, all paths under the cmd/ folder are built, specify a different folder list with `-props "{buildpaths: ["other/path", "to/build"]}"`
  linters: [] # List of linters to run on the lint target, if left empty : run all fast linters
  lintersno: ["scopelint", "forbidigo"] # List of linters to exclude on running the lint target
  dockerfiles: # List of Dockerfiles to build, defined by a map of {key=Dockerfile name ; value=path to build context}, the image name will be determined by the extension of the Dockerfile
    Dockerfile: . # Build a file named Dockerfile at the root of the workspace, will produce image name "<DOCKERHUB_USER>/<PROJECT>"
    Dockerfile.webserver: . # Build a file named Dockerfile.webserver at the root of the workspace, will produce image name "<DOCKERHUB_USER>/<PROJECT>-webserver"

targets:
  help:
    doc: "print this message"
    steps:
      # - $: 'neon -info' => incorrect order, issue to open
      - color: "cyan"
        print: "Available targets"
      - print: ""
      - print: "help        Print this message"
      - print: "info        Print build informations"
      ## Stand-alone targets
      - print: "promote     Promote the project with a new tag based on git log history"
      - print: "refresh     Refresh go modules (add missing and remove unused modules) [will trigger: info]"
      - print: "compile     Compile binary files locally [will trigger: info->refresh]"
      ## Continuous Integration
      - print: "lint        Examine source code and report suspicious constructs [will trigger: info->refresh]"
      - print: "test        Run all tests with coverage [will trigger: info->refresh->lint]"
      - print: "release     Compile binary files for production [will trigger: info->refresh->lint->test]"
      - print: "docker      Build docker images [will trigger: info]"
      - print: "docker-tag  Tag docker images [will trigger: info->docker]"
      ## Continuous Deployment
      - print: "publish     Publish tagged binary cmd's to Github [will trigger: info->refresh->lint->test]"
      - print: ""
      - print: 'Example : neon -props "{latest: true}" promote publish'

  info:
    doc: "print build informations"
    steps:
      - $: "git describe --tags --exact-match 2>/dev/null || git symbolic-ref -q --short HEAD"
        1=: "tag"
        3x: true
      - $: 'echo -n "={tag}" | sed -e s/^v//'
        1=: "version"
        3x: true
      - $: "git rev-parse HEAD 2>/dev/null"
        1=: "commit"
        3x: true
      - "date = now()[0:10]"
      - try:
          - $: "git config user.email"
            1=: "by"
            3x: true
        catch:
          - print: "User email not defined, use 'git config user.email <your email>'"
          - $: "exit 1"
      - $: 'if expr match "={version}" "\d\+\.\d\+\.\d\+" 1>/dev/null 2>&1; then echo -n "yes"; else echo -n "no"; fi'
        1=: "is_release"
        3x: true
      - $: "cut -f1 -d."
        <: "=version"
        1=: "version_major"
        3x: true
      - $: "cut -f2 -d."
        <: "=version"
        1=: "version_minor"
        3x: true
      - $: "cut -f3 -d."
        <: "=version"
        1=: "version_patch"
        3x: true
      - if: MODULE == ""
        then:
          - $: "git config --local remote.origin.url|sed -n 's#^.*//\\(.*\\)\\.git$#\\1#p'" # .*//(.*)\.git => https://github.com/<user>/<repo>.git => github.com/<user>/<repo>
            1=: "mod"
            3x: true
        else:
          - $: "echo -n ={MODULE}"
            1=: "mod"
            3x: true
      - if: PROJECT == ""
        then:
          - $: "cut -f3 -d/"
            <: "=mod"
            1=: "project"
            3x: true
        else:
          - $: "echo -n ={PROJECT}"
            1=: "project"
            3x: true
      - print: |-
          MODULE  = ={mod}
          PROJECT = ={project}
          TAG     = ={tag}
          COMMIT  = ={commit}
          DATE    = ={date}
          BY      = ={by}
          RELEASE = ={is_release}
      - if: 'is_release == "yes"'
        then:
          - print: |-
              VERSION = ={version_major}.={version_minor}.={version_patch}

  promote:
    doc: "promote the project with a new tag based on git log history"
    steps:
      - $: "git tag $(svu next || echo -n v0.1.0)"
        2x: true
      - $: "echo Promoted to $(svu current)"

  refresh:
    doc: "refresh go modules (add missing and remove unused modules)"
    depends: "info"
    steps:
      - $: "rm -f go.mod go.sum"
      - $: "go mod init ={mod}"
      - $: "go mod tidy"

  compile:
    doc: "compile binary files locally"
    depends: ["info", "refresh"]
    steps:
      - ldflags = ldflags + " -X main.version=" + tag + " -X main.commit=" + commit + " -X main.buildDate=" + date + " -X main.builtBy=" + by
      - if: len(buildpaths) == 0
        then:
          - buildpaths = appendpath("cmd", find("cmd", "*"))
      - for: path
        in: buildpaths
        do:
          - print: Building ={path}
          - |
            pathcomponents = split(unixpath(path), "/")
            name = pathcomponents[len(pathcomponents)-1]
          - $: go build -ldflags "-X main.name=={name} ={ldflags} ={LDFLAGS}" -o ./={BUILD_DIR}/={name} ./={path}

  lint:
    doc: "examine source code and report suspicious constructs"
    depends: ["info", "refresh"]
    steps:
      - if: len(linters) == 0
        then:
          - $: golangci-lint run --fast --enable-all ={replace(join(appendpath("--disable", lintersno), " "), "/", " ")}
            :: true
        else:
          - $: golangci-lint run ={replace(join(appendpath("--enable", linters), " "), "/", " ")} ={replace(join(appendpath("--disable", lintersno), " "), "/", " ")}
            :: true

  test:
    doc: "run all tests with coverage"
    depends: ["info", "refresh", "lint"]
    steps:
      - $: go test -coverprofile=./={BUILD_DIR}/coverage.txt -covermode=atomic ./...

  release:
    doc: "compile binary files for production"
    depends: ["info", "refresh", lint, "test"]
    steps:
      - ldflags = ldflags + " -s -w" # Omit the DWARF symbol table. Omit the symbol table and debug information.
      - call: compile

  publish:
    doc: "publish tagged binary cmd's to Github"
    depends: ["info", "refresh", lint, "test"]
    steps:
      - ldflags = ldflags + " -s -w" # Omit the DWARF symbol table. Omit the symbol table and debug information.
      - ldflags = ldflags + " -X main.version=" + tag + " -X main.commit=" + commit + " -X main.buildDate=" + date + " -X main.builtBy=" + by
      - $: (export LDFLAGS="={ldflags}"; cat .goreleaser.template.yml | gomplate)
        1>: ={BUILD_DIR}/.goreleaser.yml
        1x: true
      - $: goreleaser release -f ={BUILD_DIR}/.goreleaser.yml --rm-dist --snapshot # TODO : remove --rm-dist --snapshot

  docker:
    doc: "build docker images"
    depends: ["info"]
    steps:
      - for: key
        in: keys(dockerfiles)
        do:
          - |
            keycomponents = split(key, ".")
            suffix = ""
            if len(keycomponents) > 1 {
              suffix = "-" + keycomponents[len(keycomponents)-1]
            }
          - $: "sudo docker build -q --iidfile ={BUILD_DIR}/last-={key} -t ={DOCKERHUB_USER}/={project}={suffix}:={tag} -f ={key} ={dockerfiles[key]}"
            1x: true
          - $: "sudo docker images --no-trunc | grep $(cat ={BUILD_DIR}/last-={key})"

  # run "neon -props '{latest: true}' docker-tag" to include latest tag
  docker-tag:
    doc: "tag docker images"
    # unless: 'is_release != "yes"' => is_release unknown variable, issue to open
    depends: ["info", "docker"]
    steps:
      - if: 'is_release == "yes"'
        then:
          - for: key
            in: keys(dockerfiles)
            do:
              - |
                keycomponents = split(key, ".")
                suffix = ""
                if len(keycomponents) > 1 {
                  suffix = "-" + keycomponents[len(keycomponents)-1]
                }
              - $: "sudo docker tag ={DOCKERHUB_USER}/={project}={suffix}:={tag} ={DOCKERHUB_USER}/={project}={suffix}:v={version_major}"
              - $: "sudo docker tag ={DOCKERHUB_USER}/={project}={suffix}:={tag} ={DOCKERHUB_USER}/={project}={suffix}:v={version_major}.={version_minor}"
              - if: "latest"
                then:
                  - $: "sudo docker tag ={DOCKERHUB_USER}/={project}={suffix}:={tag} ={DOCKERHUB_USER}/={project}={suffix}:latest"
              - $: "sudo docker images --no-trunc | grep $(cat ={BUILD_DIR}/last-={key})"
        else:
          - print: "Skipping release target (not a release)"
            color: red

  docker-login:
    steps:
      - try:
          - $: "sudo docker login -u ={DOCKERHUB_USER} -p ={DOCKERHUB_PASS}"
            2x: true
        catch:
          - print: |
              To use this target, make sure your credentials are valid in the file ~/.dockerhub.yml
              The content of the file should be :
                DOCKERHUB_USER: <your dockerhub user>
                DOCKERHUB_PASS: <your dockerhub password or a dockerhub token>
          - $: return 1

  # run "neon -props '{latest: true}' docker-publish" to include latest tag
  docker-publish:
    doc: "push docker images to Dockerhub"
    # unless: 'is_release != "yes"' => is_release unknown variable, issue to open
    depends: ["info", "release", "docker-login"]
    steps:
      - if: 'is_release == "yes"'
        then:
          - $: "echo TODO"
          # - $: 'sudo docker push adrienaury/go-devcontainer:={tag}'
          # - $: 'sudo docker push adrienaury/go-devcontainer:v={version_major}'
          # - $: 'sudo docker push adrienaury/go-devcontainer:v={version_major}.={version_minor}'
          - if: "latest"
            then:
              - $: "echo TODO"
            # - $: 'sudo docker push adrienaury/go-devcontainer:latest'
        else:
          - print: "Skipping release target (not a release)"
            color: red
